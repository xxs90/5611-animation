/* autogenerated by Processing revision 1293 on 2023-09-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CollisionTest extends PApplet {

int canvasWidth = 800;
float s = canvasWidth / 10;
ArrayList<Circle> circles = new ArrayList<Circle>();
ArrayList<Line> lines = new ArrayList<Line>();
ArrayList<Box> boxes = new ArrayList<Box>();


double duration;
ArrayList<Double> durationList = new ArrayList<Double>(); 

public void setup() {
  /* size commented out by preprocessor */;
  surface.setTitle("Collision Detection Visulaize [CSCI 5611 HW1]");

  String userInput = input("Which task do you wan to solve? ");
  String inputFile = "./CollisionTasks/task" + userInput + ".txt";
  String outputFile = "./test_CollisionTasks/task" + userInput + "_solution.txt";
  readFile(inputFile);
  ArrayList<Integer> uniqueId = checkCollision();
  writeFile(outputFile, uniqueId); 
  
}

public ArrayList<Integer> checkCollision() {
  ArrayList<Integer> collisionId = new ArrayList<Integer>();
  // ArrayList<Integer> ccCollisionId = new ArrayList<Integer>();
  // ArrayList<Integer> clCollisionId = new ArrayList<Integer>();
  // ArrayList<Integer> cbCollisionId = new ArrayList<Integer>();
  // ArrayList<Integer> llCollisionId = new ArrayList<Integer>();
  // ArrayList<Integer> lbCollisionId = new ArrayList<Integer>();
  // ArrayList<Integer> bbCollisionId = new ArrayList<Integer>();
    
  long startTimes = System.nanoTime();

  // Iterate through Circles
  for (int i = 0; i < circles.size(); i++) {
    for (int j = i + 1; j < circles.size(); j++) {
      Circle circle1 = circles.get(i);
      Circle circle2 = circles.get(j);

      boolean collision = circleCircleCollision(circle1, circle2);
      
      // Display collision result
      if (collision) {
        collisionId.add(circle1.id);
        collisionId.add(circle2.id);
        // ccCollisionId.add(circle1.id);
        // ccCollisionId.add(circle2.id);
      }
      
    }
  }

  // Iterate through Circles and Lines
  for (int i = 0; i < circles.size(); i++) {
    for (int j = 0; j < lines.size(); j++) {
      Circle circle = circles.get(i);
      Line line = lines.get(j);

      boolean collision = circleLineCollision(circle, line);

      if (collision) {
        collisionId.add(circle.id);
        collisionId.add(line.id);
        // clCollisionId.add(circle.id);
        // clCollisionId.add(line.id);
      }

    }
  }

  // Iterate through Circles and Boxes
  for (int i = 0; i < circles.size(); i++) {
    for (int j = 0; j < boxes.size(); j++) {
      Circle circle = circles.get(i);
      Box box = boxes.get(j);

      boolean collision = circleBoxCollision(circle, box);

      if (collision) {
        collisionId.add(circle.id);
        collisionId.add(box.id);
        // cbCollisionId.add(circle.id);
        // cbCollisionId.add(box.id);
      }
    }
  }

  // Iterate through Lines
  for (int i = 0; i < lines.size(); i++) {
    for (int j = i + 1; j < lines.size(); j++) {
      Line line1 = lines.get(i);
      Line line2 = lines.get(j);

      boolean collision = lineLineCollision(line1, line2);
      
      if (collision) {
        collisionId.add(line1.id);
        collisionId.add(line2.id);
        // llCollisionId.add(line1.id);
        // llCollisionId.add(line2.id);
      }
    }
  }

  // Iterate through Lines and Boxes
  for (int i = 0; i < lines.size(); i++) {
    for (int j = 0; j < boxes.size(); j++) {
      Line line = lines.get(i);
      Box box = boxes.get(j);

      boolean collision = lineBoxCollision(line, box);
      
      if (collision) {
        collisionId.add(line.id);
        collisionId.add(box.id);
        // lbCollisionId.add(line.id);
        // lbCollisionId.add(box.id);
      }

    }
  }

  // Iterate through Boxes
  for (int i = 0; i < boxes.size(); i++) {
    for (int j = i + 1; j < boxes.size(); j++) {
      Box box1 = boxes.get(i);
      Box box2 = boxes.get(j);

      boolean collision = boxBoxCollision(box1, box2);
      
      if (collision) {
        collisionId.add(box1.id);
        collisionId.add(box2.id);        
        // bbCollisionId.add(box1.id);
        // bbCollisionId.add(box2.id);
      }
    }
  }
  
  duration = (System.nanoTime() - startTimes) / 1e6f;
  durationList.add(duration);
  
  ArrayList<Integer> uniqueId = numCollision(collisionId);
  // ArrayList<Integer> ccUniqueId = numCollision(ccCollisionId);
  // ArrayList<Integer> clUniqueId = numCollision(clCollisionId);
  // ArrayList<Integer> cbUniqueId = numCollision(cbCollisionId);
  // ArrayList<Integer> llUniqueId = numCollision(llCollisionId);
  // ArrayList<Integer> lbUniqueId = numCollision(lbCollisionId);
  // ArrayList<Integer> bbUniqueId = numCollision(bbCollisionId);

  // println("Cirlce-cirlce collision: " + ccUniqueId.size());
  // println("Cirlce-line collision: " + clUniqueId.size());
  // println("Cirlce-box collision: " + cbUniqueId.size());
  // println("Line-line collision: " + llUniqueId.size()); 
  // println("Line-box collision: " + lbUniqueId.size());
  // println("Box-box collision: " + bbUniqueId.size());

  return uniqueId;
}

public ArrayList<Integer> numCollision(ArrayList<Integer> inputIdList) {
  ArrayList<Integer> uniqueList = new ArrayList<Integer>();

  for (Integer num : inputIdList) {
    // If the element is not already in the unique list, add it
    if (!uniqueList.contains(num)) {
      int index = 0;
      while (index < uniqueList.size() && uniqueList.get(index) < num) {
        index ++;
      }
      // insert the id to the correct position to follow the numerical order 
      uniqueList.add(index, num);
      println(num);
    }
  }
  return uniqueList;
}



// check the circle-circle collision
public boolean circleCircleCollision(Circle circle1, Circle circle2) {
  float dx = circle1.centerX - circle2.centerX;
  float dy = circle1.centerY - circle2.centerY;
  float distance = sqrt(dx * dx + dy * dy);
  return distance < (circle1.radius + circle2.radius);
}

// check the circle-line collision
public boolean circleLineCollision(Circle circle, Line line) {
  float d;
  // Calculate the squared distance from the circle's center to the line segment
  float lineLengthSquared = distSquared(line.x1, line.y1, line.x2,line.y2);
  if (lineLengthSquared == 0) {
    // The line segment is just a point, so return the squared distance to that point
    d = distSquared(circle.centerX, circle.centerY, line.x1, line.y1);
  }

  // Calculate the t parameter (0 <= t <= 1) for the closest point on the line segment
  float t = ((circle.centerX - line.x1) * (line.x2 - line.x1) + (circle.centerY - line.y1) * (line.y2 - line.y1)) / lineLengthSquared;
  
  // Clamp t to ensure it lies within the line segment
  t = max(0, min(1, t));
  
  // Calculate the coordinates of the closest point on the line segment
  float closestX = line.x1 + t * (line.x2 - line.x1);
  float closestY = line.y1 + t * (line.y2 - line.y1);
  
  // Calculate the squared distance from the point to the closest point on the line
  d = distSquared(circle.centerX, circle.centerY, closestX, closestY);

  // If the squared distance is less than the squared radius, there is an intersection
  return d <= pow(circle.radius, 2);
}

// Helper function to calculate the squared distance between two points (x1, y1) and (x2, y2).
public float distSquared(float x1, float y1, float x2, float y2) {
  float dx = x2 - x1;
  float dy = y2 - y1;
  return dx * dx + dy * dy;
}

// check the circle-box collision
public boolean circleBoxCollision(Circle circle, Box box) {
  float closestX = constrain(circle.centerX, box.centerX-box.widthBox/2, box.centerX+box.widthBox/2);
  float closestY = constrain(circle.centerY, box.centerY-box.heightBox/2, box.centerY+box.heightBox/2);
  float dx = circle.centerX - closestX;
  float dy = circle.centerY - closestY;
  float distance = sqrt(dx * dx + dy * dy);
  return distance < circle.radius;
}

// check line-line collision
public boolean lineLineCollision(Line line1, Line line2) {
  float x1 = line1.x1;
  float y1 = line1.y1;
  float x2 = line1.x2;
  float y2 = line1.y2;
  
  float x3 = line2.x1;
  float y3 = line2.y1;
  float x4 = line2.x2;
  float y4 = line2.y2;

  // Calculate the direction vectors of the lines
  float dx1 = x2 - x1;
  float dy1 = y2 - y1;
  float dx2 = x4 - x3;
  float dy2 = y4 - y3;

  // Calculate the determinant of the direction vectors
  float det = dx1 * dy2 - dx2 * dy1;

  // Check if the lines are parallel (det ~= 0)
  if (abs(det) < 0.0001f) {
    return false;
  }

  // Calculate parameters for the lines
  float t1 = ((x3 - x1) * dy2 - (y3 - y1) * dx2) / det;
  float t2 = ((x3 - x1) * dy1 - (y3 - y1) * dx1) / det;

  // Check if the intersection point is within the line segments
  return t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1;
}

// check the line-box collision
public boolean lineBoxCollision(Line line, Box box) {
  
  float xMin = box.centerX-box.widthBox/2;
  float xMax = box.centerX+box.widthBox/2;
  float yMin = box.centerY-box.heightBox/2;
  float yMax = box.centerY+box.heightBox/2;
  // println("Box id is: " + box.id);
  // println("xMin: " + xMin);
  // println("xMax: " + xMax);
  // println("yMin: " + yMin);
  // println("yMax: " + yMax);

  // Check if the line is completely out of the box
  if (line.x1 < xMin && line.x2 < xMin) return false;
  if (line.x1 > xMax && line.x2 > xMax) return false;
  if (line.y1 < yMin && line.y2 < yMin) return false;
  if (line.y1 > yMax && line.y2 > yMax) return false;

  // Check if the line starts inside the box
  if ((line.x1 >= xMin && line.x1 <= xMax && line.y1 >= yMin && line.y1 <= yMax) || // Start point is inside the box
      (line.x2 >= xMin && line.x2 <= xMax && line.y2 >= yMin && line.y2 <= yMax)) { // Intersects right edge
    return true;
  }

  // Check if the four line of box intersect with the box
  Line line1 = new Line(box.id, xMin, yMin, xMin, yMax);
  Line line2 = new Line(box.id, xMin, yMax, xMax, yMax);
  Line line3 = new Line(box.id, xMax, yMax, xMax, yMin);
  Line line4 = new Line(box.id, xMax, yMin, xMin, yMin);
  if (lineLineCollision(line, line1) || lineLineCollision(line, line2) || 
  lineLineCollision(line, line3) || lineLineCollision(line, line4)) {
    return true;
  }
  
  return false;
}

// check the box-box collision 
public boolean boxBoxCollision(Box box1, Box box2) {
  return !(box1.centerX+box1.widthBox/2 < box2.centerX-box2.widthBox/2 || 
  box1.centerX-box1.widthBox/2 > box2.centerX+box2.widthBox/2 || 
  box1.centerY+box1.heightBox/2 < box2.centerY-box2.heightBox/2 || 
  box1.centerY-box1.heightBox/2 > box2.centerY+box2.heightBox/2);
}

// read file function
public void readFile(String inputFilePath) {

  try {
    BufferedReader reader = createReader(inputFilePath);

    String dataType = null;
    int count = -1;
    int id = -1;

    String line;
    // read line by line 
    while ((line = reader.readLine()) != null) {
      // split the text input by space new line and :
      String[] parts = line.split("[\\s:]+");

      if (parts.length == 2) {
        // println(parts);
        dataType = parts[0];
        count = PApplet.parseInt(parts[1]);
        // println(dataType, num);
      } else if (dataType != null && !parts[0].equals("#")) {
        if (dataType.equals("Circles") && parts.length == 4) {
          // println(parts);
          Circle circleShape = new Circle(PApplet.parseInt(parts[0]), PApplet.parseFloat(parts[1]), PApplet.parseFloat(parts[2]), PApplet.parseFloat(parts[3]));
          circles.add(circleShape);
        } else if (dataType.equals("Lines") && parts.length == 5) {
          // println(parts);
          Line lineShape = new Line(PApplet.parseInt(parts[0]), PApplet.parseFloat(parts[1]), PApplet.parseFloat(parts[2]), PApplet.parseFloat(parts[3]), PApplet.parseFloat(parts[4]));
          lines.add(lineShape);
        } else if (dataType.equals("Boxes") && parts.length == 5){
          // println(parts);  
          Box boxShape = new Box(PApplet.parseInt(parts[0]), PApplet.parseFloat(parts[1]), PApplet.parseFloat(parts[2]), PApplet.parseFloat(parts[3]), PApplet.parseFloat(parts[4]));
          boxes.add(boxShape);
        } else {
          println("Not a valid shape input for detecting in this collision library");
        }
      }
    }

    reader.close();

  } catch (IOException e) {
    e.printStackTrace();
  }
}

// write file function
public void writeFile(String outputFilePath, ArrayList<Integer> uniqueId) {
  PrintWriter writer = createWriter(outputFilePath);
  writer.println("Duration: " + duration + "ms");
  writer.println("Num Collisions: " + uniqueId.size());
  // println("Cirlce-cirlce collision: " + ccUniqueId.size());
    for (Integer i : uniqueId) {
      writer.println(i);
    }

  writer.flush();
  writer.close();
}

public void draw() {
  background(255);

  strokeWeight(1);
  stroke(0);
  for (Line lineShape : lines) {
    line(lineShape.x1 * s, lineShape.y1 * s, lineShape.x2 * s, lineShape.y2 * s);
  }
  
  noStroke();
  fill(10, 120, 10);
  for (Circle circleShape : circles) {
    circle(circleShape.centerX * s, circleShape.centerY * s, circleShape.radius * 2 * s);
  }

  fill(180, 60, 40);
  for (Box boxShape : boxes) {
    quad((boxShape.centerX-boxShape.widthBox/2)*s, (boxShape.centerY-boxShape.heightBox/2)*s, 
    (boxShape.centerX-boxShape.widthBox/2)*s, (boxShape.centerY+boxShape.heightBox/2)*s,
    (boxShape.centerX+boxShape.widthBox/2)*s, (boxShape.centerY+boxShape.heightBox/2)*s,
    (boxShape.centerX+boxShape.widthBox/2)*s, (boxShape.centerY-boxShape.heightBox/2)*s);
  }
  

}
public class Box {
  int id;
  float centerX;
  float centerY;
  float widthBox;
  float heightBox;

  public Box(int id, float centerX, float centerY, float widthBox, float heightBox) {
    this.id = id;
    this.centerX = centerX;
    this.centerY = centerY;
    this.widthBox = widthBox;
    this.heightBox = heightBox;
  }
}
public class Circle {
  int id;
  float centerX;
  float centerY;
  float radius;

  public Circle(int id, float centerX, float centerY, float radius) {
    this.id = id;
    this.centerX = centerX;
    this.centerY = centerY;
    this.radius = radius;
  }
}
public class Line {
  int id;
  float x1;
  float y1;
  float x2;
  float y2;

  public Line(int id, float x1, float y1, float x2, float y2) {
    this.id = id;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CollisionTest" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
