/* autogenerated by Processing revision 1293 on 2023-10-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class pinball extends PApplet {


Sound s;

ArrayList<PImage> backgrounds = new ArrayList<PImage>();
int currentBackgroundIndex = 0;
boolean showBackground = false;

ArrayList<Line> walls = new ArrayList<Line>();
ArrayList<Ball> circles = new ArrayList<Ball>();
ArrayList<Ball> balls = new ArrayList<Ball>();
ArrayList<Box> blocks = new ArrayList<Box>();

int ballNumber = 1;
int lives = ballNumber;
int blockNumber = ballNumber;

Flipper flipperL;
Flipper flipperR;

float ballsize = 40;
int paddleWidth = 60;
int paddleHeight = 10;
int paddleSpeed = 5;
float paddleX;

int boxWidthLimit = 100;
int boxHeightLimit = 50;

int width = 800;
int height = 1000;
int minX = 10;
int minY = 10;
int maxX = width - minX;
int maxY = height - 100;

int score = 0;
boolean startGame = false;
boolean endGame = false;

public void setup() {
  /* size commented out by preprocessor */;

	// Load background images from a directory (you can customize this part)
	File folder = new File(sketchPath("./backgrounds/")); // Replace with your folder path
	File[] files = folder.listFiles();
	println(files);
	
	for (File file : files) {
		if (file.isFile() && file.getName().toLowerCase().endsWith(".jpg")) {
			PImage bg = loadImage(file.getAbsolutePath());
			backgrounds.add(bg);
		}
	}

	for (int i = 0; i < ballNumber; i++) {
		balls.add(new Ball(random(minX, maxX), 50, 0, 2, ballsize));
	}
	for (int i = 0; i < blockNumber; i++) {
		blocks.add(new Box(random(minX, maxX-5), random(minY, maxY-5), 10, 10, 0));
	}
	
	circles.add(new Ball(width/2, height/5, 0, 0, 120));
	circles.add(new Ball(width/4, height-200, 0, 0, 60));

	Line wallTop = new Line(minX, minY, maxX, minY);
	walls.add(wallTop);
	Line wallLeft = new Line(minX, minY, minX, maxY);
	walls.add(wallLeft);
	Line wallRight = new Line(maxX, minY, maxX, maxY);
	walls.add(wallRight);
	Line wallDownL = new Line(minX, maxY, width*1.5f/6, maxY+20);
	walls.add(wallDownL);
	Line wallDownR = new Line(maxX, maxY, width*4.5f/6, maxY+20);
	walls.add(wallDownR);
	Line wall1 = new Line(width/10, width/6, width/4, height/3);
	walls.add(wall1);
	Line wall2 = new Line(width*9/10, height/2, width*7/10, height*3/4);
	walls.add(wall2);
	
	paddleX = (width - paddleWidth) / 2;
	flipperL = new Flipper(width*1.5f/6, maxY+20, width*2.75f/6, maxY+60, PI/120);
	flipperR = new Flipper(width*3.25f/6, maxY+60, width*4.5f/6, maxY+20, PI/120);
   
}

public void draw() {
  frameRate(120);
  background(255, 255, 255);

	if (!startGame) {
		fill(0, 0, 0);
		textSize(48);
		textAlign(CENTER, CENTER);
		text("PinBall Game", width/2, height/2-50);
		textSize(24);
		text("Press 'Enter' to start game!", width/2, height/2);
	}
	else {
		if (!endGame) {
			if (showBackground && backgrounds.size() > 0) {
				// Display the current background image
				image(backgrounds.get(currentBackgroundIndex), 0, 0, width, height);
			}

			// Draw balls
			for (int i = 0; i < balls.size(); i++) {
				Ball ball = balls.get(i);
				// println("Speed x " + ball.speedX);
				// println("Speed y " + ball.speedY);
				ball.move();
				// println("New Speed x " + ball.speedX);
				// println("New Speed y " + ball.speedY);

				// Check for collisions
				for (int j = 0; j < balls.size(); j++) {
					if (i != j) {
						ball.checkCollisionBalls(balls.get(j));
					}
				}

				for (Ball circle : circles) {
					ball.checkCollisionWithStaticBall(circle);
				}

				for (Box block : blocks) {
					ball.checkCollision(block);
				}
				
				for (Line wall : walls) {
					println("Before hit wall: x: " + ball.speedX + " m/s, y: " + ball.speedY + "m/s");
					ball.checkCollisionWithWall(wall);
				}
				
				ball.checkCollision(flipperL);
				ball.checkCollision(flipperR);

				ball.display();

				if (ball.y > maxY+60) {
					balls.remove(i);
					loseLife();
				}

			}

			// Draw blocks
			for (int i = 0; i < blocks.size(); i++) {
				blocks.get(i).display();
			}
			// Draw lines
			for (int i = 0; i < walls.size(); i++) {
				walls.get(i).display();
			}

			// Draw big balls
			for (int i = 0; i < circles.size(); i++) {
				circles.get(i).displayBigBall();
			}

			// Draw flippers
			if (!keyPressed){
				flipperL.rotateObjectBack();
				flipperR.rotateObjectBack();
			}
			flipperL.display();
			flipperR.display();

			fill(0, 0, 0);
			textSize(12);
			textAlign(LEFT);
			text("Life: ", width-80, 25);
			text(lives, width-40, 25);
			text("Score: ", width-80, 35);
			text(score, width-40, 35);
		}
		else {
			fill(0, 0, 0);
			textSize(48);
			textAlign(CENTER, CENTER);
			text("GAME OVER", width/2, height/2-50);
			textSize(24);
			text("Press 'e' to exit game!", width/2, height/2);
		}
	}

}

public void keyPressed() {
  if (keyCode == ENTER) {
		startGame = true;
	}
	else if (keyCode == LEFT) {
    flipperL.rotateObject();
  }// if the key 'z' is pressed, rotate the paddle.
	else if (keyCode == RIGHT) {
		flipperR.rotateObject();
	}
  else if (key == 'y' || key == 'Y') {
    showBackground = true;
  }  
  else if (key == 'n' || key == 'N') {
    showBackground = false;
  }
  else if ((key == 't' || key == 'T') && showBackground) {
    if (backgrounds.size() > 0) {
      // Switch to the next background image when the "t" key is pressed
      currentBackgroundIndex = (currentBackgroundIndex + 1) % backgrounds.size();
    }
  }
	else if (key == 'e' || key == 'E') {
		exit();
	}
}

public void loseLife() {
	lives--;

	if (balls.size() == 0) {
		endGame = true;
	}
}
public class Ball {
	float x, y;
	float speedX, speedY;
	float radius;

	public Ball(float x, float y, float speedX, float speedY, float size) {
		this.x = x;
		this.y = y;
		this.speedX = speedX;
		this.speedY = speedY;
		this.radius = size/2;
	}

	public void move() {
		x += speedX;
		y += speedY;
		// println("Speed x" + x);
		// println("Speed y" + y);
	}

	// void checkCollision() {
	// 	if (x < minX || x > maxX) {
	// 		speedX *= -1;
	// 	}
			
	// 	if (y < minY) {
	// 		// speedY *= -1;
	// 		speedY *= 1;
	// 	}
			
	// 	if (y > height - minY - paddleHeight && x > paddleX && x < paddleX + paddleWidth) {
	// 		// speedY *= -1;
	// 		speedY *= 1;
	// 	}
	// }

	// check the collision between the ball and the other Rectangle.
	public void checkCollision(Box r) {
		// check if the ball intersects with the for sides of the rectangle
		Line top = new Line(r.x, r.y, r.x + r.width, r.y);
		Line bottom = new Line(r.x, r.y + r.height, r.x + r.width, r.y + r.height);
		Line left = new Line(r.x, r.y, r.x, r.y + r.height);
		Line right = new Line(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
		if (checkCollisionWithWall(top) || checkCollisionWithWall(bottom) || checkCollisionWithWall(left) || checkCollisionWithWall(right)) {
			score += 5;
			return;
		}
	}

	// check the collision between two balls by commparing the distance between the centers of the two balls and the sum of their radius.
	public void checkCollisionBalls(Ball b) {
		Vec2 distance_v = new Vec2(x - b.x, y - b.y);
		float distance = distance_v.mag();
		if (distance <= radius + b.radius) {
			float r = radius + b.radius;
			Vec2 mid = new Vec2((x + b.x) / 2, (y + b.y) / 2);
			Vec2 ball1 =  distance_v.normalize().mult(r/1.5f).add(mid);
			Vec2 ball2 =  mid.sub(distance_v.normalize().mult(r/1.5f));
			x = ball1.x;
			y = ball1.y;
			b.x = ball2.x;
			b.y = ball2.y;
			
			// calculate the reflecting velocity of the two balls.
			Vec2 v1 = new Vec2(speedX, speedY);
			Vec2 v2 = new Vec2(b.speedX, b.speedY);
			Vec2 n = new Vec2(distance_v.x, distance_v.y).normalize();
			Vec2 r1 = v1.sub(n.mult(2 * v1.dot(n)));
			Vec2 r2 = v2.sub(n.mult(2 * v2.dot(n)));
			speedX = r1.x;
			speedY = r1.y;
			b.speedX = r2.x;
			b.speedY = r2.y;
		}
	}

	// check the collision between stationary ball and moving ball.
	public void checkCollisionWithStaticBall(Ball ball) {
		float dx = x - ball.x;
		float dy = y - ball.y;
		float distance = sqrt(dx * dx + dy * dy);

		if (distance <= radius + ball.radius) {
			// Calculate the collision normal (unit vector pointing from stationaryBall to movingBall)
			float nx = dx / distance;
			float ny = dy / distance;

			// Calculate dot product of relative velocity and normal vector
			float dotProduct = speedX * nx + speedY * ny;

			// Calculate impulse (change in velocity)
			float impulseX = 2.0f * dotProduct * nx;
			float impulseY = 2.0f * dotProduct * ny;

			// Update the moving ball's velocity
			speedX -= impulseX;
			speedY -= impulseY;

			// Separate the balls to avoid overlap
			float overlap = (radius + ball.radius) - distance;
			float pushX = (overlap / 2.0f) * nx;
			float pushY = (overlap / 2.0f) * ny;

			speedX += pushX;
			speedY += pushY * 1.2f;

			score += 1;
		}
	}

	public boolean checkCollisionWithWall(Line l){
		float damping = 0.5f;
    // Calculate the vector components of the line segment
    float dx = l.x2 - l.x1;
    float dy = l.y2 - l.y1;

    // Calculate the length of the line segment
    double d = Math.sqrt(dx * dx + dy * dy);

    // Calculate the parameter 'u' that determines the closest point on the line to the ball
    float u = ((x - l.x1) * dx + (y - l.y1) * dy) / ((float)d * (float)d);
    
    // Clamp 'u' to the range [0, 1] to ensure it's within the line segment
    if (u > 1) {
			u = 1;
    } else if (u < 0) {
			u = 0;
    }

    // Calculate the coordinates of the closest point on the line
    float closestX = l.x1 + u * dx;
    float closestY = l.y1 + u * dy;

    // Calculate the distance between the ball's center and the closest point on the line
    float distanceX = closestX - x;
    float distanceY = closestY - y;
    double distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

    // Check if a collision occurs by comparing the distance to the ball's radius
    if (distance <= radius) {
			// Calculate the reflecting velocity of the ball
			Vec2 v = new Vec2(speedX, speedY); // Ball's velocity vector
			Vec2 n = new Vec2((float)distanceX, (float)distanceY).normalize(); // Normal vector at collision point
			Vec2 r = v.sub(n.mult(2 * v.dot(n))); // Reflecting velocity
			
			// Apply damping to the velocity
  		r.mult(damping); // Multiply by the damping factor to slow down the ball

			// Update the ball's position to just touch the line
			x = (float)closestX - (float)distanceX / (float)distance * radius;
			y = (float)closestY - (float)distanceY / (float)distance * radius;
			
			// Update the ball's velocity to the reflecting velocity
			speedX = r.x;
			speedY = r.y + 2;
    }
    
    return false; // This return value may need to be adjusted based on the context of your code
	}


	// Check the collision between the ball and flippers
	public boolean checkCollision(Flipper flipper){
		float damping = 0.2f;
		// Calculate the vector components of the line segment
    float dx = flipper.x2 - flipper.x1;
    float dy = flipper.y2 - flipper.y1;

    // Calculate the length of the line segment
    double d = Math.sqrt(dx * dx + dy * dy);

    // Calculate the parameter 'u' that determines the closest point on the line to the ball
    float u = ((x - flipper.x1) * dx + (y - flipper.y1) * dy) / ((float)d * (float)d);
    
    // Clamp 'u' to the range [0, 1] to ensure it's within the line segment
    if (u > 1) {
			u = 1;
    } else if (u < 0) {
			u = 0;
    }

    // Calculate the coordinates of the closest point on the line
    float closestX = flipper.x1 + u * dx;
    float closestY = flipper.y1 + u * dy;

    // Calculate the distance between the ball's center and the closest point on the line
    float distanceX = closestX - x;
    float distanceY = closestY - y;
    double distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

    // Check if a collision occurs by comparing the distance to the ball's radius
    if (distance <= radius) {
			// Calculate the reflecting velocity of the ball
			Vec2 v = new Vec2(speedX, speedY); // Ball's velocity vector
			Vec2 n = new Vec2((float)distanceX, (float)distanceY).normalize(); // Normal vector at collision point
			Vec2 r = v.sub(n.mult(2 * v.dot(n))); // Reflecting velocity
			
			// Apply damping to the velocity
  		r.mult(damping); // Multiply by the damping factor to slow down the ball

			// Update the ball's position to just touch the line
			x = (float)closestX - (float)distanceX / (float)distance * radius;
			y = (float)closestY - (float)distanceY / (float)distance * radius;
			
			// Update the ball's velocity to the reflecting velocity
			speedX = r.x;
			speedY = r.y;
    }
    
    return false; // This return value may need to be adjusted based on the context of your code
	                                                                                                                                                      
	}

	public void display() {
		fill(0, 0, 255);
		noStroke();
		circle(x, y, radius*2);
	}

	public void displayBigBall() {
		fill(50, 128, 200);
		noStroke();
		circle(x, y, radius*2);
	}

	// void reset(float newX, float newY) {
	// 	x = newX;
	// 	y = newY;
	// 	speedX = random(-3, 3);
	// 	speedY = random(1, 3);
	// }
}
public class Box {
  float x, y;
  float width, height;
  float speedX;
  float angle = 0;

  public Box (float x, float y, float width, float height, float speedX) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.speedX = speedX;
  }
  
  public void display() {
    noStroke();
    fill(125, 125, 125);
    rect(x, y, width, height);
  }

  public void moveLeft() {
    x -= speedX;
  }

  public void moveRight() {
    x += speedX;
  }
}
public class Flipper {
  float x1, y1, x2, y2;
  float x, y;
  float width, height;
  float speedX = 5;
  float jitter = PI/360;
  float jitter_current = 0;
  float angle = 0;
  boolean flipPaddle = false;

  public Flipper (float x1, float y1, float x2, float y2, float jitter) {
    this.x1 = x1; this.y1 = y1;
    this.x2 = x2; this.y2 = y2;
    this.x = (x1 + x2) / 2;
    this.y = (y1 + y2) / 2;
    this.width = x1-x2;
    this.height = y1-y2;
    this.speedX = 3;
    this.jitter = jitter;
  }

  public void display() {
    stroke(150, 100, 200);
	strokeWeight(4);
    line(x1, y1, x2, y2);
  }

  public void moveLeft() {
    x1 -= speedX;
    x2 -= speedX;
  }

  public void moveRight() {
    x1 += speedX;
    x2 += speedX;
  }

  // write a rotate function using matrix transformation for the line segment.
  public void rotateObject() {
    if (angle < 50){
      angle += 1;
			jitter_current = jitter;
      // println(angle);
    } else {
			jitter_current = 0;
    }
		
		// Apply jitter to the line segment
		Vec2 v = new Vec2(x2 - x1, y2 - y1);
		float length = v.mag();
		
		v.x = v.x * cos(jitter_current) - v.y * sin(jitter_current);
		v.y = v.x * sin(jitter_current) + v.y * cos(jitter_current);
		x2 = x1 + v.normalize().mult(length).x;
		y2 = y1 + v.normalize().mult(length).y;
	}

  public void rotateObjectBack() {
    if (angle > 0){
    	angle -= 2;
      jitter_current = -2*jitter;
    } else {
			jitter_current = 0;
    }
		
		Vec2 v = new Vec2(x2 - x1, y2 - y1);
  	float length = v.mag();
		
		v.x = v.x * cos(jitter_current) - v.y * sin(jitter_current);
    v.y = v.x * sin(jitter_current) + v.y * cos(jitter_current);
    x2 = x1 + v.normalize().mult(length).x;
    y2 = y1 + v.normalize().mult(length).y;
  }
	
	

  
  // void flipPaddle() {
  //     if (flipPaddle) {
  //         if (paddle.angle < radians(60)) {
  //         paddle.angle += radians(5);                     
  //         }
  //     }
  // }

  // // check if the line segment intersects with the rectangle
  // boolean intersects(Rectangle r) {
  //     // check if the line segment intersects with any of the four sides of the rectangle
  //     LineSegment top = new LineSegment(r.x, r.y, r.x + r.width, r.y);
  //     LineSegment bottom = new LineSegment(r.x, r.y + r.height, r.x + r.width, r.y + r.height);
  //     LineSegment left = new LineSegment(r.x, r.y, r.x, r.y + r.height);
  //     LineSegment right = new LineSegment(r.x + r.width, r.y, r.x + r.width, r.y + r.height);

  //     return intersects(top) || intersects(bottom) || intersects(left) || intersects(right);
  // }

  // // check if the line segment intersects with another line segment
  // boolean intersects(LineSegment l) {
  //     // check if the two line segments are parallel
  //     float denominator = (l.y2 - l.y1) * (x2 - x1) - (l.x2 - l.x1) * (y2 - y1);
  //     if (denominator == 0) {
  //         return false;
  //     }

  //     // calculate the intersection point
  //     float ua = ((l.x2 - l.x1) * (y1 - l.y1) - (l.y2 - l.y1) * (x1 - l.x1)) / denominator;
  //     float ub = ((x2 - x1) * (y1 - l.y1) - (y2 - y1) * (x1 - l.x1)) / denominator;

  //     // check if the intersection point is on both line segments
  //     if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
  //         return true;
  //     }

  //     return false;
  // }
}
public class Line {
  float x1, y1, x2, y2;
  float x, y;
  float width, height;
  float speedX = 5;
  float angle = 0;

  public Line (float x1, float y1, float x2, float y2) {
    this.x1 = x1; this.y1 = y1;
    this.x2 = x2; this.y2 = y2;
    this.x = (x1 + x2) / 2;
    this.y = (y1 + y2) / 2;
  }

  public void display() {
    stroke(0, 0, 0);
		strokeWeight(4);
    line(x1, y1, x2, y2);
  }
}
class Vec2 {
	float x, y;
	
	Vec2(float x, float y) {
		this.x = x;
		this.y = y;
	}
	
	public Vec2 add(Vec2 v) {
		return new Vec2(x + v.x, y + v.y);
	}
	
	public Vec2 sub(Vec2 v) {
		return new Vec2(x - v.x, y - v.y);
	}
	
	public Vec2 mult(float scalar) {
		return new Vec2(x * scalar, y * scalar);
	}
	
	public float mag() {
		return sqrt(x * x + y * y);
	}
	
	public Vec2 normalize() {
		float m = mag();
		if (m != 0) {
			return mult(1 / m);
		} else {
			return new Vec2(0, 0);
		}
	}
	
	public float dot(Vec2 v) {
		return x * v.x + y * v.y;
	}
	
	public Vec2 cross(Vec2 v) {
		return new Vec2(0, 0);
	}
}


  public void settings() { size(800, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "pinball" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
